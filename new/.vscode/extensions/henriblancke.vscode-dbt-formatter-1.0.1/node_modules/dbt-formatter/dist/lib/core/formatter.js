"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var indentation_1 = require("./indentation");
var inline_block_1 = require("./inline-block");
var constants_1 = require("../constants");
var normalize = require("../utils/normalize");
var token_types_1 = require("../constants/token-types");
// Whitespaces:
// 1. The previous token will always append a whitespace (if needed).
// 2. You probably don't have to append a whitespace to start of token.
// Tokens:
// 1. Always try to derive rules based on next token when dependencies are necassary
var Formatter = /** @class */ (function () {
    function Formatter(opt) {
        var _this = this;
        this.upper = false;
        this.newline = true;
        this.variableName = '';
        this.lowerWords = false;
        this.allowCamelcase = true;
        this.inlineOneLiner = false;
        this.inTemplateBlock = false;
        this.inVariableBlock = false;
        this.inIncrementalBlock = false;
        this.inlineBlock = new inline_block_1.default();
        this.previousReservedWord = { type: '', value: '' };
        this.format = function (tokens) {
            var e_1, _a;
            var formattedQuery = '';
            try {
                for (var _b = __values(tokens.items()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var node = _c.value;
                    var token = node.item;
                    // order of statements is important
                    if (token.type === token_types_1.default.DBT_START_VAR) {
                        formattedQuery = _this.formatVariableStart(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.DBT_END_VAR) {
                        formattedQuery = _this.formatVariableEnd(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.DBT_START_TEMPLATE) {
                        formattedQuery = _this.formatTemplateStart(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.DBT_END_TEMPLATE) {
                        formattedQuery = _this.formatTemplateEnd(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.DBT_START_MARKERS) {
                        formattedQuery = _this.formatDBTStartMarker(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.DBT_END_MARKERS) {
                        formattedQuery = _this.formatDBTEndMarker(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.WHITESPACE) {
                        // ignore (we do our own whitespace formatting)
                    }
                    else if (token.type === token_types_1.default.LINE_COMMENT) {
                        formattedQuery = _this.formatLineComment(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.BLOCK_COMMENT) {
                        formattedQuery = _this.formatBlockComment(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.RESERVED_TOPLEVEL) {
                        formattedQuery = _this.formatToplevelReservedWord(node, formattedQuery);
                        _this.previousReservedWord = token;
                    }
                    else if (token.type === token_types_1.default.RESERVED_NEWLINE) {
                        formattedQuery = _this.formatNewlineReservedWord(node, formattedQuery);
                        _this.previousReservedWord = token;
                    }
                    else if (token.type === token_types_1.default.RESERVED) {
                        formattedQuery = _this.formatReservedWord(node, formattedQuery);
                        _this.previousReservedWord = token;
                    }
                    else if (token.type === token_types_1.default.OPEN_PAREN) {
                        formattedQuery = _this.formatOpeningParentheses(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.CLOSE_PAREN) {
                        formattedQuery = _this.formatClosingParentheses(node, formattedQuery);
                    }
                    else if (token.value === ',') {
                        formattedQuery = _this.formatComma(node, formattedQuery);
                    }
                    else if (token.value === ':') {
                        formattedQuery = _this.formatWithSpaceAfter(node, formattedQuery);
                    }
                    else if (token.value === '.') {
                        formattedQuery = _this.formatWithoutSpaces(node, formattedQuery);
                    }
                    else if (token.value === ';') {
                        formattedQuery = _this.formatQuerySeparator(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.OPERATOR) {
                        formattedQuery = _this.formatOperator(node, formattedQuery);
                    }
                    else if (token.type === token_types_1.default.WORD) {
                        formattedQuery = _this.formatWord(node, formattedQuery);
                    }
                    else {
                        formattedQuery = _this.formatWithSpaces(node, formattedQuery);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var appendix = _this.newline ? '\n' : '';
            return formattedQuery.trim() + appendix;
        };
        this.indentComment = function (comment) {
            return comment.replace(/\n/g, '\n' + _this.indentation.getIndent());
        };
        this.trimTrailingWhitespace = function (node, query) {
            var appendix = '';
            var nextType = node.next ? node.next.item.type : undefined;
            if (nextType === token_types_1.default.LINE_COMMENT) {
                appendix = '\n';
            }
            return normalize.trimEnd(query) + appendix;
        };
        this.addNewline = function (query, lines) {
            if (lines === void 0) { lines = 1; }
            return normalize.trimEnd(query) + '\n'.repeat(lines) + _this.indentation.getIndent();
        };
        this.getNextNodeNonWhitespace = function (node) {
            var nextNode = node.next;
            while (nextNode && nextNode.item.type === token_types_1.default.WHITESPACE) {
                nextNode = nextNode.next;
            }
            return nextNode;
        };
        this.getPreviousNodeNonWhitespace = function (node) {
            var previousNode = node.previous;
            while (previousNode && previousNode.item.type === token_types_1.default.WHITESPACE) {
                previousNode = previousNode.previous;
            }
            return previousNode;
        };
        this.countWordsBetweenParenthesis = function (node) {
            if (node.item.type !== token_types_1.default.OPEN_PAREN) {
                return 0;
            }
            var wordCount = 0;
            var nextNode = node.next;
            while (nextNode && nextNode.item.type !== token_types_1.default.CLOSE_PAREN) {
                if (nextNode.item.value !== ',') {
                    wordCount++;
                }
                nextNode = nextNode.next;
            }
            return wordCount;
        };
        /*
         * FORMATTERS
         */
        this.formatVariableStart = function (node, query) {
            _this.inVariableBlock = true;
            var token = node.item;
            var nextToken = _this.getNextNodeNonWhitespace(node);
            _this.variableName = nextToken ? nextToken.item.value : '';
            return query + normalize.addWhitespace(normalize.removeWhitespace(token.value));
        };
        this.formatVariableEnd = function (node, query) {
            _this.inVariableBlock = false;
            // Remove whitespaces from token and add space at the end
            var token = node.item.value;
            var nextToken = _this.getNextNodeNonWhitespace(node);
            query += normalize.addWhitespace(normalize.removeWhitespace(token));
            // If the next token is a reserved word (as, when,...) don't add
            // a new line.
            var noNewLine = nextToken &&
                (nextToken.item.type === token_types_1.default.RESERVED || nextToken.item.type === token_types_1.default.OPERATOR ||
                    constants_1.DbtConfig.dbtControl.includes(nextToken.item.value.toLowerCase()));
            if (noNewLine) {
                return query;
            }
            /*
             ** Logic when to add a double new line **
             * If the next token is a reserved top level sql word -> add 2 lines
             * If the next token is a dbt template start token -> add 2 lines
             */
            var doubleLine = nextToken &&
                (nextToken.item.type === token_types_1.default.RESERVED_TOPLEVEL || nextToken.item.type === token_types_1.default.DBT_START_TEMPLATE);
            var lines = doubleLine ? 2 : 1;
            return _this.addNewline(query, lines);
        };
        this.formatTemplateStart = function (node, query) {
            _this.inTemplateBlock = true;
            var token = node.item;
            var nextToken = _this.getNextNodeNonWhitespace(node);
            var previousToken = _this.getPreviousNodeNonWhitespace(node);
            var secondNextToken = nextToken ? _this.getNextNodeNonWhitespace(nextToken) : undefined;
            var newToken = normalize.addWhitespace(normalize.removeWhitespace(token.value));
            /*
             ** Currently there are two special cases in jinja that we account for here:
             * 1. {% else % }: needs to be format 1 indent down
             * 2. {% if is_incremental() %}: needs to reset to indent: 0
             */
            if (nextToken && nextToken.item.value.toLowerCase() === 'else') {
                _this.indentation.decreaseTopLevel();
                query = _this.addNewline(query);
                _this.indentation.increaseToplevel();
            }
            else if (nextToken &&
                constants_1.DbtConfig.dbtControl.includes(nextToken.item.value.toLowerCase()) &&
                (secondNextToken && secondNextToken.item.value.toLowerCase() === 'is_incremental')) {
                _this.indentation.reset();
                _this.inIncrementalBlock = true;
                query = _this.addNewline(query, 2);
            }
            else if (nextToken && nextToken.item.type === token_types_1.default.DBT_END_MARKERS) {
                var isTopLevel = constants_1.DbtConfig.topLevelWords.includes(nextToken.item.value.toLowerCase());
                if (isTopLevel) {
                    _this.indentation.reset();
                }
                else {
                    _this.indentation.decreaseTopLevel();
                }
                query = _this.addNewline(query);
            }
            else if (nextToken &&
                nextToken.item.type === token_types_1.default.DBT_START_MARKERS &&
                !constants_1.DbtConfig.singleLineWords.includes(nextToken.item.value.toLowerCase())) {
                _this.indentation.increaseToplevel();
                if (previousToken && previousToken.item.type === token_types_1.default.WORD) {
                    // if previous token is a word, give it some space and decrease indentation
                    _this.indentation.decreaseTopLevel();
                    query = _this.addNewline(query, 2);
                }
            }
            return query + newToken;
        };
        this.formatTemplateEnd = function (node, query) {
            _this.inTemplateBlock = false;
            var token = node.item;
            query += normalize.addWhitespace(token.value);
            var previousToken = _this.getPreviousNodeNonWhitespace(node);
            var doubleLineMarker = previousToken && previousToken.item.value
                ? constants_1.DbtConfig.doubleLineMarkers.includes(previousToken.item.value.toLowerCase())
                : false;
            var lines = doubleLineMarker ? 2 : 1;
            return _this.addNewline(query, lines);
        };
        this.formatDBTStartMarker = function (node, query) {
            var token = node.item;
            return query + normalize.addWhitespace(token.value);
        };
        this.formatDBTEndMarker = function (node, query) {
            var token = node.item;
            return query + normalize.addWhitespace(token.value);
        };
        this.formatLineComment = function (node, query) {
            var token = node.item;
            return _this.addNewline(query + token.value);
        };
        this.formatBlockComment = function (node, query) {
            var token = node.item;
            return _this.addNewline(_this.addNewline(query) + _this.indentComment(token.value));
        };
        this.formatReservedWord = function (node, query) {
            var token = node.item;
            token.value =
                _this.upper && !_this.inTemplateBlock && !_this.inVariableBlock ? token.value.toUpperCase() : token.value;
            return _this.formatWithSpaces(node, query);
        };
        this.formatToplevelReservedWord = function (node, query) {
            var token = node.item;
            var prevToken = _this.getPreviousNodeNonWhitespace(node);
            // if we are inside dbt template brackets don't add newline
            // there is some sql and jinja overlap that we account for here.
            if ((prevToken && prevToken.item.type === token_types_1.default.DBT_START_TEMPLATE) ||
                _this.inTemplateBlock ||
                _this.inVariableBlock) {
                var newToken_1 = normalize.addWhitespace(token.value.toLowerCase());
                return query + normalize.equalizeWhitespace(newToken_1);
            }
            // WITH table as () is a special case.
            if (token.value.toLowerCase() === 'with') {
                var newToken_2 = normalize.addWhitespace(_this.upper ? token.value.toUpperCase() : token.value);
                return query + normalize.equalizeWhitespace(newToken_2);
            }
            // when in `is_incremental` block keep current indentation level
            // if the previous token is a dbt config variable keep current indentation
            var previousConfigBlock = _this.variableName.toLowerCase() === 'config';
            if (_this.inIncrementalBlock || previousConfigBlock) {
                _this.variableName = '';
                _this.inIncrementalBlock = false;
            }
            else {
                _this.indentation.decreaseTopLevel();
            }
            query = _this.addNewline(query, previousConfigBlock ? 2 : 1);
            // TODO: Make reusable function
            var newToken = _this.upper ? token.value.toUpperCase() : token.value;
            query += normalize.equalizeWhitespace(newToken);
            _this.indentation.increaseToplevel();
            query = _this.addNewline(query);
            return query;
        };
        this.formatNewlineReservedWord = function (node, query) {
            var token = node.item;
            if (_this.inTemplateBlock) {
                var newToken_3 = normalize.addWhitespace(token.value.toLowerCase());
                return query + normalize.equalizeWhitespace(newToken_3);
            }
            var newToken = _this.upper ? token.value.toUpperCase() : token.value;
            return _this.addNewline(query) + normalize.addWhitespace(newToken);
        };
        // Opening parentheses increase the block indent level and start a new line
        this.formatOpeningParentheses = function (node, query) {
            // Take out the preceding space unless there was whitespace there in the original query
            // or another opening parens or line comment
            var preserveWhitespaceFor = [token_types_1.default.WHITESPACE, token_types_1.default.OPEN_PAREN, token_types_1.default.LINE_COMMENT];
            if (node.previous && !preserveWhitespaceFor.includes(node.previous.item.type)) {
                query = normalize.trimEnd(query);
            }
            // dirty fix for when we allow a word to have the same function as an opening parenthesis
            query += _this.upper ? node.item.value.toUpperCase() : node.item.value;
            _this.inlineBlock.beginIfPossible(node);
            var nextNode = _this.getNextNodeNonWhitespace(node);
            /*
             ** Determine if text within parentheses should be a one liner
             * 1. When the there is no text `()`
             * 2. When there is only 1 word in between brackets
             */
            _this.inlineOneLiner = _this.countWordsBetweenParenthesis(node) <= 1;
            // only increase block level when inline block is active and next token is not a closing parenthesis
            if (!_this.inlineBlock.isActive() && !_this.inlineOneLiner) {
                _this.indentation.increaseBlockLevel();
                query = _this.addNewline(query);
            }
            return query;
        };
        // Closing parentheses decrease the block indent level
        this.formatClosingParentheses = function (node, query) {
            // dirty fix for when we allow a word to have the same function as a closing parenthesis
            node.item.value = _this.upper ? node.item.value.toUpperCase() : node.item.value;
            if (_this.inlineBlock.isActive()) {
                _this.inlineBlock.end();
                return _this.formatWithSpaceAfter(node, query);
            }
            else if (_this.inlineOneLiner) {
                _this.inlineOneLiner = false;
                return _this.formatWithSpaceAfter(node, query);
            }
            else {
                _this.indentation.decreaseBlockLevel();
                return _this.formatWithSpaces(node, _this.addNewline(query));
            }
        };
        // Commas start a new line (unless within inline parentheses or SQL "LIMIT" clause)
        this.formatComma = function (node, query) {
            var token = node.item;
            query = _this.trimTrailingWhitespace(node, query) + token.value + ' ';
            if (_this.inlineBlock.isActive()) {
                return query;
            }
            else if (/^LIMIT$/i.test(_this.previousReservedWord.value)) {
                return query;
            }
            else {
                return _this.addNewline(query);
            }
        };
        this.formatOperator = function (node, query) {
            var token = node.item;
            var prevToken = _this.getPreviousNodeNonWhitespace(node);
            if (prevToken && prevToken.item.type === token_types_1.default.OPERATOR) {
                return normalize.trimEnd(query) + normalize.removeWhitespace(token.value) + ' ';
            }
            return _this.formatWithSpaces(node, query);
        };
        this.formatWithSpaceAfter = function (node, query) {
            var token = node.item;
            return _this.trimTrailingWhitespace(node, query) + normalize.addWhitespace(token.value);
        };
        this.formatWithoutSpaces = function (node, query) {
            var token = node.item;
            return _this.trimTrailingWhitespace(node, query) + token.value;
        };
        this.formatWithSpaces = function (node, query) {
            var token = node.item;
            return query + normalize.addWhitespace(token.value);
        };
        this.formatWord = function (node, query) {
            var token = node.item;
            var newToken = token.value;
            if (_this.lowerWords) {
                var isCamelCase = normalize.isCamelCase(token.value);
                newToken = isCamelCase && _this.allowCamelcase ? token.value : token.value.toLowerCase();
            }
            return query + normalize.addWhitespace(newToken);
        };
        this.formatQuerySeparator = function (node, query) {
            var token = node.item;
            return _this.trimTrailingWhitespace(node, query) + token.value + '\n';
        };
        var indent = opt.indent, upper = opt.upper, newline = opt.newline, lowerWords = opt.lowerWords, allowCamelcase = opt.allowCamelcase;
        this.upper = upper || this.upper;
        this.newline = newline || this.newline;
        this.indentation = new indentation_1.default(indent);
        this.lowerWords = lowerWords || this.lowerWords;
        this.allowCamelcase = allowCamelcase || this.allowCamelcase;
    }
    return Formatter;
}());
exports.default = Formatter;
//# sourceMappingURL=formatter.js.map