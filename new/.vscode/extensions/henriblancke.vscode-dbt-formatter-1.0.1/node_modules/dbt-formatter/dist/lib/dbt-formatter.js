"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tokenizer_1 = require("./core/tokenizer");
var formatter_1 = require("./core/formatter");
var constants_1 = require("./constants");
var getConfiguration = function (opt) {
    var identifier = opt.sql;
    return {
        reservedWords: constants_1.presets['reservedWords'][identifier],
        reservedTopLevelWords: constants_1.presets['reservedTopLevelWords'][identifier],
        reservedNewLineWords: constants_1.presets['reservedNewLineWords'][identifier],
        stringTypes: constants_1.presets['stringTypes'][identifier],
        openParens: constants_1.presets['openParens'][identifier],
        closeParens: constants_1.presets['closeParens'][identifier],
        indexedPlaceholderTypes: constants_1.presets['indexedPlaceholderTypes'][identifier],
        namedPlaceholderTypes: constants_1.presets['namedPlaceholderTypes'][identifier],
        lineCommentTypes: constants_1.presets['lineCommentTypes'][identifier],
        specialWordChars: constants_1.presets['specialWordChars'][identifier],
    };
};
/**
 * Formats the sql string.
 *
 * @param {String} query
 * @param {Options} opt
 * @return {String}
 */
var format = function (query, opt) {
    if (opt === void 0) { opt = { sql: 'default', indent: 2 }; }
    if (!constants_1.formatters.includes(opt.sql)) {
        throw Error("Unsupported SQL dialect: " + opt.sql);
    }
    var config = getConfiguration(opt);
    var tokens = new tokenizer_1.default(config).tokenize(query);
    return new formatter_1.default(opt).format(tokens);
};
exports.default = format;
//# sourceMappingURL=dbt-formatter.js.map