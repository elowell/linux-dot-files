(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('lodash')) :
    typeof define === 'function' && define.amd ? define(['lodash'], factory) :
    (global.dbtFormatter = factory(global.lodash));
}(this, (function (lodash) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    var formatters = ['default'];
    var DbtConfig = {
        dbtControl: ['and', 'as', 'else', 'if', 'in', 'import', 'not', 'or', 'recursive'],
        topLevelWords: ['macro', 'endmacro', 'snapshot', 'endsnapshot'],
        singleLineWords: ['set'],
        startMarkers: ['set', 'block', 'filter', 'for', 'if', 'macro', 'raw', 'call', 'snapshot'],
        endMarkers: ['endblock', 'endfilter', 'endfor', 'endif', 'endmacro', 'endraw', 'endcall', 'endsnapshot'],
        doubleLineMarkers: ['endcall', 'endif', 'endmacro', 'endfor', 'endsnapshot'],
    };
    var presets = {
        reservedWords: {
            // prettier-ignore
            default: ['A', 'ABS', 'ACCESSIBLE', 'ACOS', 'ACOSH', 'ADD_MONTHS', 'AGENT',
                'AGGREGATE', 'ALL', 'ALTER', 'ANY', 'ANY_VALUE',
                'APPROXIMATE_JACCARD_INDEX', 'APPROXIMATE_SIMILARITY',
                'APPROX_COUNT_DISTINCT', 'APPROX_PERCENTILE',
                'APPROX_PERCENTILE_ACCUMULATE', 'APPROX_PERCENTILE_COMBINE',
                'APPROX_PERCENTILE_ESTIMATE', 'APPROX_TOP_K',
                'APPROX_TOP_K_ACCUMULATE', 'APPROX_TOP_K_COMBINE',
                'APPROX_TOP_K_ESTIMATE', 'ARRAY', 'ARRAYS_OVERLAP', 'ARRAY_AGG',
                'ARRAY_APPEND', 'ARRAY_CAT', 'ARRAY_COMPACT', 'ARRAY_CONSTRUCT',
                'ARRAY_CONSTRUCT_COMPACT', 'ARRAY_CONTAINS', 'ARRAY_INSERT',
                'ARRAY_POSITION', 'ARRAY_PREPEND', 'ARRAY_SIZE', 'ARRAY_SLICE',
                'ARRAY_TO_STRING', 'AS', 'ASC', 'ASCII', 'ASIN', 'ASINH',
                'AS_ARRAY', 'AS_BINARY', 'AS_BOOLEAN', 'AS_CHAR', 'AS_DATE',
                'AS_DECIMAL', 'AS_DOUBLE', 'AS_INTEGER', 'AS_NUMBER', 'AS_OBJECT',
                'AS_REAL', 'AS_TIME', 'AS_VARCHAR', 'AT', 'ATAN', 'ATAN2', 'ATANH',
                'ATTRIBUTE', 'AUTHID', 'AUTOMATIC_CLUSTERING_HIST', 'AVG',
                'BASE64_DECODE_BINARY', 'BASE64_DECODE_STRING', 'BASE64_ENCODE',
                'BETWEEN', 'BFILE_BASE', 'BINARY', 'BINARY_INTEGER', 'BITAND',
                'BITAND_AGG', 'BITNOT', 'BITOR', 'BITOR_AGG', 'BITSHIFTLEFT',
                'BITSHIFTRIGHT', 'BITXOR', 'BITXOR_AGG', 'BIT_LENGTH', 'BLOB_BASE',
                'BLOCK', 'BODY', 'BOOLAND', 'BOOLEAN', 'BOOLNOT', 'BOOLOR',
                'BOOLXOR', 'BOTH', 'BOUND', 'BULK', 'BY', 'BYTE', 'C', 'CALL',
                'CALLING', 'CASCADE', 'CASE', 'CAST', 'CBRT', 'CEIL', 'CHAR',
                'CHARACTER', 'CHARINDEX', 'CHARSET', 'CHARSETFORM', 'CHARSETID',
                'CHAR_BASE', 'CHECK', 'CHECK_JSON', 'CHECK_XML', 'CHR',
                'CLOB_BASE', 'CLONE', 'CLOSE', 'CLUSTER', 'CLUSTERS', 'COALESCE',
                'COLAUTH', 'COLLATE', 'COLLATION', 'COLLECT', 'COLUMNS', 'COMMENT',
                'COMMIT', 'COMMITTED', 'COMPILED', 'COMPRESS', 'CONCAT', 'CONNECT',
                'CONSTANT', 'CONSTRUCTOR', 'CONTAINS', 'CONTEXT', 'CONTINUE',
                'CONVERT', 'CONVERT_TIMEZONE', 'COPY_HISTORY', 'CORR', 'COS',
                'COSH', 'COT', 'COUNT', 'COVAR_POP', 'COVAR_SAMP', 'CRASH',
                'CREATE', 'CREDENTIAL', 'CUME_DIST', 'CURRENT', 'CURRENT_ACCOUNT',
                'CURRENT_CLIENT', 'CURRENT_DATABASE', 'CURRENT_DATE',
                'CURRENT_ROLE', 'CURRENT_SCHEMA', 'CURRENT_SCHEMAS',
                'CURRENT_SESSION', 'CURRENT_STATEMENT', 'CURRENT_TIME',
                'CURRENT_TIMESTAMP', 'CURRENT_TRANSACTION', 'CURRENT_USER',
                'CURRENT_VERSION', 'CURRENT_WAREHOUSE', 'CURRVAL', 'CURSOR',
                'CUSTOMDATUM', 'DANGLING', 'DATA', 'DATABASE_STORAGE_USAGE_HI',
                'DATA_TRANSFER_HISTORY', 'DATE', 'DATEADD', 'DATEDIFF',
                'DATE_BASE', 'DATE_FROM_PARTS', 'DATE_PART', 'DATE_TRUNC', 'DAY',
                'DAYNAME', 'DECIMAL', 'DECODE', 'DECOMPRESS_BINARY',
                'DECOMPRESS_STRING', 'DEFAULT', 'DEFINE', 'DEGREES',
                'DENSE_RANK', 'DESC', 'DETERMINISTIC', 'DIRECTORY', 'DISTINCT',
                'DO', 'DOUBLE', 'DROP', 'DURATION', 'EDITDISTANCE', 'ELEMENT',
                'ELSIF', 'EMPTY', 'ENDSWITH', 'EQUAL_NULL', 'ESCAPE', 'EXCEPTIONS',
                'EXCLUSIVE', 'EXECUTE', 'EXISTS', 'EXIT', 'EXP', 'EXTENDS',
                'EXTERNAL', 'EXTERNAL_TABLE_FILES', 'EXTERNAL_TABLE_FILE_REGIS',
                'EXTRACT', 'FACTORIAL', 'FALSE', 'FETCH', 'FINAL', 'FIRST',
                'FIRST_VALUE', 'FIXED', 'FLATTEN', 'FLOAT', 'FLOOR', 'FOR',
                'FORALL', 'FORCE', 'FUNCTION', 'GENERAL', 'GENERATOR',
                'GET', 'GET_DDL', 'GET_OBJECT_REFERENCES', 'GET_PATH , :', 'GOTO',
                'GRANT', 'GREATEST', 'GROUP', 'GROUPING', 'GROUPING_ID', 'HASH',
                'HASH_AGG', 'HAVERSINE', 'HEAP', 'HEX_DECODE_BINARY',
                'HEX_DECODE_STRING', 'HEX_ENCODE', 'HIDDEN', 'HLL',
                'HLL_ACCUMULATE', 'HLL_COMBINE', 'HLL_ESTIMATE', 'HLL_EXPORT',
                'HLL_IMPORT', 'HOUR', 'IDENTIFIED', 'IF', 'IFF', 'IFNULL', 'ILIKE',
                'IMMEDIATE', 'IN', 'INCLUDING', 'INDEX', 'INDEXES', 'INDICATOR',
                'INDICES', 'INFINITE', 'INITCAP', 'INSTANTIABLE', 'INT',
                'INTEGER', 'INTERFACE', 'INTERVAL', 'INTO', 'INVALIDATE', 'IS',
                'IS DISTINCT FROM', 'IS NOT DISTINCT FROM', 'IS NOT NULL',
                'IS NULL', 'ISOLATION', 'IS_ARRAY', 'IS_BINARY', 'IS_BOOLEAN',
                'IS_CHAR', 'IS_DATE', 'IS_DATE_VALUE', 'IS_DECIMAL', 'IS_DOUBLE',
                'IS_INTEGER', 'IS_NULL_VALUE', 'IS_OBJECT', 'IS_REAL', 'IS_TIME',
                'IS_VARCHAR', 'JAVA', 'LAG', 'LANGUAGE', 'LARGE', 'LAST_DAY',
                'LAST_QUERY_ID', 'LAST_TRANSACTION', 'LAST_VALUE', 'LEAD',
                'LEADING', 'LEAST', 'LEFT', 'LENGTH', 'LEVEL', 'LIBRARY', 'LIKE',
                'LIKE ANY', 'LIKE2', 'LIKE4', 'LIKEC', 'LIMITED', 'LISTAGG', 'LN',
                'LOCAL', 'LOCALTIME', 'LOCALTIMESTAMP', 'LOCK', 'LOG',
                'LOGIN_HISTORY', 'LOGIN_HISTORY_BY_USER', 'LONG', 'LOWER', 'LPAD',
                'LTRIM', 'MAP', 'MATERIALIZED_VIEW_REFRESH_HISTORY', 'MAX',
                'MAXLEN', 'MD5', 'MD5_BINARY', 'MD5_HEX', 'MEDIAN', 'MEMBER',
                'MERGE', 'MIN', 'MINHASH', 'MINHASH_COMBINE', 'MINUS', 'MINUTE',
                'MLSLABEL', 'MOD', 'MODE', 'MONTH', 'MONTHNAME', 'MULTISET',
                'NAME', 'NAN', 'NATIONAL', 'NATIVE', 'NATURAL', 'NATURALN',
                'NCHAR', 'NEW', 'NEXTVAL', 'NEXT_DAY', 'NOCOMPRESS', 'NOCOPY',
                'NORMAL', 'NOT', 'NOT BETWEEN', 'NOT IN', 'NOWAIT', 'NTH_VALUE',
                'NTILE', 'NULL', 'NULLIF', 'NUMBER', 'NUMBER_BASE', 'NVL', 'NVL2',
                'OBJECT', 'OBJECT_AGG', 'OBJECT_CONSTRUCT', 'OBJECT_DELETE',
                'OBJECT_INSERT', 'OCICOLL', 'OCIDATE', 'OCIDATETIME',
                'OCIDURATION', 'OCIINTERVAL', 'OCILOBLOCATOR', 'OCINUMBER',
                'OCIRAW', 'OCIREF', 'OCIREFCURSOR', 'OCIROWID', 'OCISTRING',
                'OCITYPE', 'OCTET_LENGTH', 'OF', 'OLD', 'ONLY', 'OPAQUE',
                'OPEN', 'OPERATOR', 'OPTION', 'ORACLE', 'ORADATA', 'ORDER',
                'ORGANIZATION', 'ORLANY', 'ORLVARY', 'OTHERS', 'OUT', 'OVERLAPS',
                'OVERRIDING', 'PACKAGE', 'PARALLEL_ENABLE', 'PARAMETER',
                'PARAMETERS', 'PARENT', 'PARSE_IP', 'PARSE_JSON', 'PARSE_URL',
                'PARSE_XML', 'PARTITION', 'PASCAL', 'PCTFREE', 'PERCENTILE_CONT',
                'PERCENTILE_DISC', 'PERCENT_RANK', 'PI', 'PIPE', 'PIPELINED',
                'PIPE_USAGE_HISTORY', 'PLS_INTEGER', 'PLUGGABLE', 'POSITION',
                'POSITIVE', 'POSITIVEN', 'POW, POWER', 'PRAGMA', 'PRECISION',
                'PREVIOUS_DAY', 'PRIOR', 'PRIVATE', 'PROCEDURE', 'PUBLIC',
                'QUERY_HISTORY', 'RADIANS', 'RAISE', 'RANDOM', 'RANDSTR', 'RANGE',
                'RANK', 'RATIO_TO_REPORT', 'RAW', 'READ', 'REAL', 'RECORD',
                'REFERENCE', 'REGEXP', 'REGEXP_COUNT', 'REGEXP_INSTR',
                'REGEXP_LIKE', 'REGEXP_REPLACE', 'REGEXP_SUBSTR', 'REGR_AVGX',
                'REGR_AVGY', 'REGR_COUNT', 'REGR_INTERCEPT', 'REGR_R2',
                'REGR_SLOPE', 'REGR_SXX', 'REGR_SXY', 'REGR_SYY', 'REGR_VALX',
                'REGR_VALY', 'RELEASE', 'RELIES_ON', 'REM', 'REMAINDER', 'RENAME',
                'REPEAT', 'REPLACE', 'RESOURCE', 'RESULT', 'RESULT_CACHE',
                'RESULT_SCAN', 'RETURN', 'RETURNING', 'REVERSE', 'REVOKE', 'RIGHT',
                'RLIKE', 'ROLLBACK', 'ROUND', 'ROW', 'ROWID', 'ROWNUM', 'ROWTYPE',
                'ROW_NUMBER', 'RPAD', 'RTRIM', 'RTRIMMED_LENGTH', 'SAMPLE', 'SAVE',
                'SAVEPOINT', 'SB1', 'SB2', 'SB4', 'SECOND', 'SEGMENT', 'SELF',
                'SEPARATE', 'SEQ1', 'SEQ2', 'SEQ4', 'SEQ8', 'SEQUENCE',
                'SERIALIZABLE', 'SHA1', 'SHA1_BINARY', 'SHA1_HEX', 'SHA2',
                'SHA2_BINARY', 'SHA2_HEX', 'SHARE', 'SHORT', 'SIGN', 'SIN', 'SINH',
                'SIZE', 'SIZE_T', 'SMALLINT', 'SOME', 'SOUNDEX', 'SPACE', 'SPARSE',
                'SPLIT', 'SPLIT_PART', 'SPLIT_TO_TABLE', 'SQL', 'SQLCODE',
                'SQLDATA', 'SQLERRM', 'SQLNAME', 'SQLSTATE', 'SQRT', 'SQUARE',
                'STAGE_STORAGE_USAGE_HISTORY', 'STANDARD', 'START', 'STARTSWITH',
                'STATIC', 'STDDEV', 'STDDEV_POP', 'STDDEV_SAMP', 'STORED', 'STORY',
                'STRING', 'STRIP_NULL_VALUE', 'STRTOK', 'STRTOK_SPLIT_TO_TABLE',
                'STRTOK_TO_ARRAY', 'STRUCT', 'STYLE', 'SUBMULTISET',
                'SUBPARTITION', 'SUBSTITUTABLE', 'SUBSTR', 'SUBSTRING', 'SUBTYPE',
                'SUCCESSFUL', 'SUM', 'SYNONYM', 'SYSDATE', 'TABAUTH', 'TABLE',
                'TAN', 'TANH', 'TASK_DEPENDENTS', 'TASK_HISTORY', 'TDO', 'THE',
                'THEN', 'TIME', 'TIMEADD', 'TIMEDIFF', 'TIMESTAMP', 'TIMESTAMPADD',
                'TIMESTAMPDIFF', 'TIMESTAMP_FROM_PARTS', 'TIMEZONE_ABBR',
                'TIMEZONE_HOUR', 'TIMEZONE_LTZ', 'TIMEZONE_MINUTE', 'TIMEZONE_NTZ',
                'TIMEZONE_REGION', 'TIME_FROM_PARTS', 'TIME_SLICE', 'TO',
                'TO_ARRAY', 'TO_BINARY', 'TO_BOOLEAN', 'TO_CHAR , TO_VARCHAR',
                'TO_DATE', 'TO_DECIMAL', 'TO_DOUBLE', 'TO_JSON', 'TO_NUMBER',
                'TO_NUMERIC', 'TO_OBJECT', 'TO_TIME', 'TO_TIMESTAMP', 'TO_TIMESTAMP_NTZ',
                'TO_TIMESTAMP_LTZ', 'TO_TIMESTAMP_TZ', 'TO_VARIANT', 'TO_XML', 'TRAILING',
                'TRANSACTION', 'TRANSACTIONAL', 'TRANSLATE', 'TRATION_HISTORY', 'TRIGGER',
                'TRIM', 'TRUE', 'TRUNC', 'TRUNCATE',
                'TRUSTED', 'TRY_BASE64_DECODE_BINARY', 'TRY_BASE64_DECODE_STRING',
                'TRY_CAST', 'TRY_HEX_DECODE_BINARY', 'TRY_HEX_DECODE_STRING',
                'TRY_PARSE_JSON', 'TRY_TO_BINARY', 'TRY_TO_BOOLEAN', 'TRY_TO_DATE',
                'TRY_TO_DECIMAL', 'TRY_TO_DECIMAL, TRY_TO_NUMBER', 'TRY_TO_DOUBLE',
                'TRY_TO_NUMBER', 'TRY_TO_NUMERIC', 'TRY_TO_TIME',
                'TRY_TO_TIMESTAMP', 'TRY_TO_TIMESTAMP_NTZ', 'TYPE', 'TYPEOF',
                'UB1', 'UB2', 'UB4', 'UID', 'UNDER', 'UNICODE', 'UNIFORM',
                'UNIQUE', 'UNPLUG', 'UNSIGNED', 'UNTRUSTED', 'UPPER', 'USE',
                'USER', 'USING', 'UUID_STRING', 'VALIDATE', 'VALIST', 'VALUE',
                'VARCHAR', 'VARCHAR2', 'VARIABLE', 'VARIANCE', 'VARIANCE_POP',
                'VARIANCE_SAMP', 'VARRAY', 'VARYING', 'VAR_POP', 'VAR_SAMP',
                'VIEW', 'VIEWS', 'VOID', 'WAREHOUSE_LOAD_HISTORY',
                'WAREHOUSE_METERING_HISTORY', 'WHENEVER', 'WHILE', 'WIDTH_BUCKET',
                'WORK', 'WRAPPED', 'WRITE', 'XMLGET', 'YEAR', 'ZEROIFNULL', 'ZIPF',
                'ZONE', 'LATERAL']
        },
        reservedTopLevelWords: {
            // prettier-ignore
            default: ['ADD', 'ALTER COLUMN', 'ALTER TABLE', 'BEGIN', 'CONNECT BY', 'DECLARE', 'DELETE FROM',
                'DELETE', 'END', 'EXCEPT', 'EXCEPTION', 'FETCH FIRST', 'GROUP BY', 'HAVING',
                'INSERT INTO', 'INSERT', 'INTERSECT', 'LIMIT', 'LOOP', 'MODIFY', 'ORDER BY', 'SELECT',
                'SET CURRENT SCHEMA', 'SET SCHEMA', 'SET', 'START WITH', 'UNION ALL', 'UNION', 'UPDATE',
                'VALUES', 'WHERE', 'WITH', 'FROM']
        },
        reservedNewLineWords: {
            // prettier-ignore
            default: ['AND', 'CROSS APPLY', 'CROSS JOIN', 'ELSE', 'END', 'INNER JOIN', 'JOIN', 'LEFT JOIN',
                'LEFT OUTER JOIN', 'OR', 'OUTER APPLY', 'OUTER JOIN', 'RIGHT JOIN', 'RIGHT OUTER JOIN',
                'WHEN', 'XOR', 'ON']
        },
        stringTypes: {
            default: ["\"\"", "N''", "''", '``', '[]'],
        },
        openParens: {
            default: ['(', 'CASE'],
        },
        closeParens: {
            default: [')', 'END'],
        },
        indexedPlaceholderTypes: {
            default: ['?'],
        },
        namedPlaceholderTypes: {
            default: ['@', ':'],
        },
        lineCommentTypes: {
            default: ['#', '--', '{#', '#}'],
        },
        specialWordChars: {
            default: [""],
        },
    };

    var tokenTypes = {
        DBT_START_VAR: 'dbt-variable-start',
        DBT_END_VAR: 'dbt-variable-end',
        DBT_START_TEMPLATE: 'dbt-template-start',
        DBT_START_MARKERS: 'dbt-start-markers',
        DBT_END_MARKERS: 'dbt-end-markers',
        DBT_END_TEMPLATE: 'dbt-template-end',
        WHITESPACE: 'whitespace',
        WORD: 'word',
        STRING: 'string',
        RESERVED: 'reserved',
        RESERVED_TOPLEVEL: 'reserved-toplevel',
        RESERVED_NEWLINE: 'reserved-newline',
        OPERATOR: 'operator',
        OPEN_PAREN: 'open-paren',
        CLOSE_PAREN: 'close-paren',
        LINE_COMMENT: 'line-comment',
        BLOCK_COMMENT: 'block-comment',
        NUMBER: 'number',
        PLACEHOLDER: 'placeholder',
    };

    var LinkedList = /** @class */ (function () {
        function LinkedList() {
            var _this = this;
            this.EMPTY_NODE = { item: {}, next: undefined };
            this.head = this.EMPTY_NODE;
            this.tail = this.EMPTY_NODE;
            this.getHead = function () { return _this.head; };
            this.getTail = function () { return _this.tail; };
            this.insert = function (value) {
                var node = _this.forgeNode(value);
                node.next = _this.head;
                if (_this.head) {
                    _this.head.previous = node;
                }
                _this.head = node;
                if (!_this.tail) {
                    _this.tail = node;
                }
                return _this;
            };
            this.append = function (value) {
                var node = _this.forgeNode(value);
                if (_this.isEmpty()) {
                    _this.head = node;
                    _this.tail = node;
                    return _this;
                }
                _this.appendToTheEndOfTheList(node);
                return _this;
            };
            this.fromArray = function (values) {
                values.forEach(function (v) { return _this.append(v); });
                return _this;
            };
            this.toArray = function () {
                var result = [];
                _this.iterate(function (_) { return result.push(_); });
                return result;
            };
            this.size = function () {
                var listSize = 0;
                _this.iterate(function (_) { return listSize++; });
                return listSize;
            };
            this.isEmpty = function () { return !_this.head || _this.head === _this.EMPTY_NODE; };
            this.iterate = function (accept) {
                var node = _this.head;
                while (node.next) {
                    accept(node.item);
                    node = node.next;
                }
            };
            this.forgeNode = function (value) {
                return { item: value, next: undefined };
            };
            this.appendToTheEndOfTheList = function (node) {
                node.previous = _this.tail;
                _this.tail.next = node;
                _this.tail = node;
            };
        }
        LinkedList.prototype.items = function () {
            var node;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        node = this.head;
                        _a.label = 1;
                    case 1:
                        if (!node.next) return [3 /*break*/, 3];
                        return [4 /*yield*/, node];
                    case 2:
                        _a.sent();
                        node = node.next;
                        return [3 /*break*/, 1];
                    case 3: return [4 /*yield*/, this.tail];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        };
        return LinkedList;
    }());

    var Tokenizer = /** @class */ (function () {
        /**
         * @param {Object} cfg
         *  @param {String[]} cfg.reservedWords Reserved words in SQL
         *  @param {String[]} cfg.reservedToplevelWords Words that are set to new line separately
         *  @param {String[]} cfg.reservedNewlineWords Words that are set to newline
         *  @param {String[]} cfg.stringTypes String types to enable: "", '', ``, [], N''
         *  @param {String[]} cfg.openParens Opening parentheses to enable, like (, [
         *  @param {String[]} cfg.closeParens Closing parentheses to enable, like ), ]
         *  @param {String[]} cfg.indexedPlaceholderTypes Prefixes for indexed placeholders, like ?
         *  @param {String[]} cfg.namedPlaceholderTypes Prefixes for named placeholders, like @ and :
         *  @param {String[]} cfg.lineCommentTypes Line comments to enable, like # and --
         *  @param {String[]} cfg.specialWordChars Special chars that can be found inside of words, like @ and #
         */
        function Tokenizer(cfg) {
            var _this = this;
            /**
             * Takes a SQL string and breaks it into tokens.
             * Each token is an object with type and value.
             *
             * @param {String} input The SQL string
             * @return {Object[]} tokens An array of tokens.
             *  @return {String} token.type
             *  @return {String} token.value
             */
            this.tokenize = function (input) {
                var token = { type: '', value: '' };
                var tokens = new LinkedList();
                // Keep going till the end of the string
                while (input.length) {
                    // Get the next token
                    var tmp = _this.getNextToken(input, token);
                    if (tmp) {
                        token = tmp;
                        tokens.append(token);
                        input = input.substring(token.value.length);
                    }
                }
                return tokens;
            };
            this.getNextToken = function (input, prev) {
                var regexes = _this.getRegexes(input, prev);
                var sorted = Object.keys(regexes).sort();
                var result = false;
                for (var id in sorted) {
                    var definition = regexes[id];
                    result = Tokenizer.matchRegex(definition);
                    if (result) {
                        break;
                    }
                }
                return result;
            };
            this.getRegexes = function (input, prev) {
                return {
                    0: {
                        input: input,
                        type: tokenTypes.DBT_START_VAR,
                        regex: /\{\s?\{\s?/,
                        description: 'Finds start of a dbt/jinja variable.',
                    },
                    1: {
                        input: input,
                        type: tokenTypes.DBT_END_VAR,
                        regex: /\s?\}\s?\}/,
                        description: 'Finds end of a dbt/jinja variable.',
                    },
                    2: {
                        input: input,
                        type: tokenTypes.DBT_START_TEMPLATE,
                        regex: /\s?\{\s?\%\-?/,
                        description: 'Finds start of a dbt/jinja template/macro.',
                    },
                    3: {
                        input: input,
                        type: tokenTypes.DBT_END_TEMPLATE,
                        regex: /\-?\%\s?\}/,
                        description: 'Finds end of a dbt/jinja template/macro.',
                    },
                    4: {
                        input: input,
                        type: tokenTypes.DBT_START_MARKERS,
                        regex: Tokenizer.createMultiWordRegex(DbtConfig.startMarkers),
                        description: 'Finds start marker words in template/macro.',
                    },
                    5: {
                        input: input,
                        type: tokenTypes.DBT_END_MARKERS,
                        regex: Tokenizer.createMultiWordRegex(DbtConfig.endMarkers),
                        description: 'Finds end marker words in template/macro.',
                    },
                    6: {
                        input: input,
                        type: tokenTypes.WHITESPACE,
                        regex: /^(\s+)/,
                    },
                    7: {
                        input: input,
                        type: tokenTypes.LINE_COMMENT,
                        regex: Tokenizer.createLineCommentRegex(_this.cfg.lineCommentTypes),
                    },
                    8: {
                        input: input,
                        type: tokenTypes.BLOCK_COMMENT,
                        regex: /^(\/\*[^]*?(?:\*\/|$))/,
                    },
                    9: {
                        input: input,
                        type: tokenTypes.STRING,
                        regex: Tokenizer.createStringRegex(_this.cfg.stringTypes),
                    },
                    10: {
                        input: input,
                        type: tokenTypes.OPEN_PAREN,
                        regex: Tokenizer.createParenRegex(_this.cfg.openParens),
                    },
                    11: {
                        input: input,
                        type: tokenTypes.CLOSE_PAREN,
                        regex: Tokenizer.createParenRegex(_this.cfg.closeParens),
                    },
                    12: {
                        input: input,
                        type: tokenTypes.PLACEHOLDER,
                        regex: Tokenizer.createPlaceholderRegex(_this.cfg.namedPlaceholderTypes, '[a-zA-Z0-9._$]+'),
                        parseFunc: function (v) { return v.slice(1); },
                        description: 'Indent named placeholder token',
                    },
                    13: {
                        input: input,
                        type: tokenTypes.PLACEHOLDER,
                        regex: Tokenizer.createPlaceholderRegex(_this.cfg.namedPlaceholderTypes, Tokenizer.createStringPattern(_this.cfg.stringTypes)),
                        parseFunc: function (v) {
                            return Tokenizer.getEscapedPlaceholderKey({
                                key: v.slice(2, -1),
                                quoteChar: v.slice(-1),
                            });
                        },
                        description: 'String named placeholder token',
                    },
                    14: {
                        input: input,
                        type: tokenTypes.PLACEHOLDER,
                        regex: Tokenizer.createPlaceholderRegex(_this.cfg.indexedPlaceholderTypes, '[0-9]*'),
                        parseFunc: function (v) { return v.slice(1); },
                        description: 'Index placeholder token',
                    },
                    15: {
                        input: input,
                        type: tokenTypes.NUMBER,
                        regex: /^((-\s*)?[0-9]+(\.[0-9]+)?|0x[0-9a-fA-F]+|0b[01]+)\b/,
                    },
                    16: {
                        input: input,
                        type: tokenTypes.RESERVED_TOPLEVEL,
                        regex: Tokenizer.getReservedWordToken(input, prev, Tokenizer.createMultiWordRegex(_this.cfg.reservedTopLevelWords)),
                    },
                    17: {
                        input: input,
                        type: tokenTypes.RESERVED_NEWLINE,
                        regex: Tokenizer.getReservedWordToken(input, prev, Tokenizer.createMultiWordRegex(_this.cfg.reservedNewLineWords)),
                    },
                    18: {
                        input: input,
                        type: tokenTypes.RESERVED,
                        regex: Tokenizer.getReservedWordToken(input, prev, Tokenizer.createMultiWordRegex(_this.cfg.reservedWords)),
                    },
                    19: {
                        input: input,
                        type: tokenTypes.WORD,
                        regex: Tokenizer.createWordRegex(_this.cfg.specialWordChars),
                    },
                    20: {
                        input: input,
                        type: tokenTypes.OPERATOR,
                        regex: /^(!=|<>|==|<=|>=|!<|!>|\|\||::|->>|->|~~\*|~~|!~~\*|!~~|~\*|!~\*|!~|.)/,
                    },
                };
            };
            this.cfg = cfg;
        }
        Tokenizer.escapeParen = function (paren) {
            if (paren.length === 1) {
                // single punctuation character
                return lodash.escapeRegExp(paren);
            }
            else {
                // longer word
                return '\\b' + paren + '\\b';
            }
        };
        // This enables the following string patterns:
        // 1. backtick quoted string using `` to escape
        // 2. square bracket quoted string (SQL Server) using ]] to escape
        // 3. double quoted string using "" or \" to escape
        // 4. single quoted string using '' or \' to escape
        // 5. national character quoted string using N'' or N\' to escape
        Tokenizer.createStringPattern = function (types) {
            var patterns = {
                '``': '((`[^`]*($|`))+)',
                '[]': '((\\[[^\\]]*($|\\]))(\\][^\\]]*($|\\]))*)',
                '""': '(("[^"\\\\]*(?:\\\\.[^"\\\\]*)*("|$))+)',
                "''": "(('[^'\\\\]*(?:\\\\.[^'\\\\]*)*('|$))+)",
                "N''": "((N'[^N'\\\\]*(?:\\\\.[^N'\\\\]*)*('|$))+)",
            };
            return types.map(function (t) { return patterns[t]; }).join('|');
        };
        Tokenizer.createLineCommentRegex = function (ids) {
            return new RegExp("^((?:" + ids.map(function (id) { return lodash.escapeRegExp(id); }).join('|') + ").*?(?:\n|$))");
        };
        Tokenizer.createMultiWordRegex = function (words) {
            var pattern = words.join('|').replace(/ /g, '\\s+');
            return new RegExp("^(" + pattern + ")\\b", 'i');
        };
        Tokenizer.createWordRegex = function (chars) {
            return new RegExp("^([\\w" + chars.join('') + "]+)");
        };
        Tokenizer.createStringRegex = function (types) {
            return new RegExp('^(' + Tokenizer.createStringPattern(types) + ')');
        };
        Tokenizer.createParenRegex = function (parens) {
            return new RegExp('^(' + parens.map(function (p) { return Tokenizer.escapeParen(p); }).join('|') + ')', 'i');
        };
        Tokenizer.createPlaceholderRegex = function (types, pattern) {
            if (lodash.isEmpty(types)) {
                return /.^/;
            }
            var typesRegex = types.map(lodash.escapeRegExp).join('|');
            return new RegExp("^((?:" + typesRegex + ")(?:" + pattern + "))");
        };
        Tokenizer.getEscapedPlaceholderKey = function (_a) {
            var key = _a.key, quoteChar = _a.quoteChar;
            return key.replace(new RegExp(lodash.escapeRegExp('\\') + quoteChar, 'g'), quoteChar);
        };
        Tokenizer.getReservedWordToken = function (input, prev, regex) {
            // A reserved word cannot be preceded by a "."
            // this makes it so in "mytable.from", "from" is not considered a reserved word
            if (prev && prev.value && prev.value === '.') {
                return /.^/;
            }
            return regex;
        };
        Tokenizer.matchRegex = function (df) {
            var matches = df.input.match(df.regex);
            if (matches && matches.index === 0) {
                return __assign({ type: df.type, value: matches[0] }, (df.parseFunc && { key: df.parseFunc(matches[0]) }));
            }
            return false;
        };
        return Tokenizer;
    }());

    var INDENT_TYPE_TOP_LEVEL = 'top-level';
    var INDENT_TYPE_BLOCK_LEVEL = 'block-level';
    /**
     * Manages indentation levels.
     *
     * There are two types of indentation levels:
     *
     * - BLOCK_LEVEL : increased by open-parenthesis
     * - TOP_LEVEL : increased by RESERVED_TOPLEVEL words
     */
    var Indentation = /** @class */ (function () {
        function Indentation(indent) {
            var _this = this;
            /**
             * @param {String} indent Indent value, default is "  " (2 spaces)
             */
            this.indent = '';
            this.indentTypes = [];
            /**
             * Resets indentation.
             */
            this.reset = function () {
                _this.indentTypes = [];
            };
            this.count = function () {
                return _this.indentTypes.length;
            };
            /**
             * Returns current indentation string.
             * @return {String}
             */
            this.getIndent = function () {
                return lodash.repeat(_this.indent, _this.indentTypes.length);
            };
            /**
             * Increases indentation by one top-level indent.
             */
            this.increaseToplevel = function () {
                _this.indentTypes.push(INDENT_TYPE_TOP_LEVEL);
            };
            /**
             * Increases indentation by one block-level indent.
             */
            this.increaseBlockLevel = function () {
                _this.indentTypes.push(INDENT_TYPE_BLOCK_LEVEL);
            };
            /**
             * Decreases indentation by one top-level indent.
             * Does nothing when the previous indent is not top-level.
             */
            this.decreaseTopLevel = function () {
                if (lodash.last(_this.indentTypes) === INDENT_TYPE_TOP_LEVEL) {
                    _this.indentTypes.pop();
                }
            };
            /**
             * Decreases indentation by one block-level indent.
             * If there are top-level indents within the block-level indent,
             * throws away these as well.
             */
            this.decreaseBlockLevel = function () {
                while (_this.indentTypes.length > 0) {
                    var type = _this.indentTypes.pop();
                    if (type !== INDENT_TYPE_TOP_LEVEL) {
                        break;
                    }
                }
            };
            this.indent = ' '.repeat(indent);
        }
        return Indentation;
    }());

    var INLINE_MAX_LENGTH = 50;
    var InlineBlock = /** @class */ (function () {
        function InlineBlock() {
            var _this = this;
            this.level = 0;
            /**
             * Begins inline block when lookahead through upcoming tokens determines
             * that the block would be smaller than INLINE_MAX_LENGTH.
             * @param  {Object[]} tokens Array of all tokens
             * @param  {Number} index Current token position
             */
            this.beginIfPossible = function (node) {
                if (_this.level === 0 && _this.isInlineBlock(node)) {
                    _this.level = 1;
                }
                else if (_this.level > 0) {
                    _this.level++;
                }
                else {
                    _this.level = 0;
                }
            };
            /**
             * Finishes current inline block.
             * There might be several nested ones.
             */
            this.end = function () {
                _this.level--;
            };
            /**
             * True when inside an inline block
             * @return {Boolean}
             */
            this.isActive = function () {
                return _this.level > 0;
            };
            // Check if this should be an inline parentheses block
            // Examples are "NOW()", "COUNT(*)", "int(10)", key(`somecolumn`), DECIMAL(7,2), {% ... %}, {{...}}
            this.isInlineBlock = function (node) {
                var level = 0;
                var length = 0;
                var currentNode = node;
                while (currentNode.next) {
                    var token = currentNode.next.item;
                    length += token.value.length;
                    if (length > INLINE_MAX_LENGTH) {
                        return false;
                    }
                    if ([tokenTypes.OPEN_PAREN, tokenTypes.DBT_START_TEMPLATE].includes(token.type)) {
                        level++;
                    }
                    else if ([tokenTypes.CLOSE_PAREN, tokenTypes.DBT_END_TEMPLATE].includes(token.type)) {
                        level--;
                        if (level === 0) {
                            return true;
                        }
                    }
                    if (InlineBlock.isForbiddenToken(token)) {
                        return false;
                    }
                    currentNode = currentNode.next;
                }
                return false;
            };
        }
        // Reserved words that cause newlines, comments and semicolons
        // are not allowed inside inline parentheses block
        InlineBlock.isForbiddenToken = function (_a) {
            var type = _a.type, value = _a.value;
            return (type === tokenTypes.RESERVED_TOPLEVEL ||
                type === tokenTypes.RESERVED_NEWLINE ||
                type === tokenTypes.BLOCK_COMMENT ||
                value === ';');
        };
        return InlineBlock;
    }());

    var trimEnd = lodash.trimEnd;
    // Replace any sequence of whitespace characters with single whitespace
    var equalizeWhitespace = function (st) {
        return st.replace(/\s+/g, ' ');
    };
    var addWhitespace = function (st, pre) {
        if (pre === void 0) { pre = false; }
        if (pre) {
            return equalizeWhitespace(' ' + st);
        }
        return equalizeWhitespace(st + ' ');
    };
    var removeWhitespace = function (st) {
        return st.replace(/\s+/g, '');
    };
    var isCamelCase = function (token) {
        var newToken = token;
        var firstLower = token[0] === token[0].toLowerCase();
        var slice = newToken.length > 1 ? token.slice(1, token.length) : newToken;
        var containsUpper = slice.toLowerCase() !== slice;
        return firstLower && containsUpper;
    };

    // Whitespaces:
    // 1. The previous token will always append a whitespace (if needed).
    // 2. You probably don't have to append a whitespace to start of token.
    // Tokens:
    // 1. Always try to derive rules based on next token when dependencies are necassary
    var Formatter = /** @class */ (function () {
        function Formatter(opt) {
            var _this = this;
            this.upper = false;
            this.newline = true;
            this.variableName = '';
            this.lowerWords = false;
            this.allowCamelcase = true;
            this.inlineOneLiner = false;
            this.inTemplateBlock = false;
            this.inVariableBlock = false;
            this.inIncrementalBlock = false;
            this.inlineBlock = new InlineBlock();
            this.previousReservedWord = { type: '', value: '' };
            this.format = function (tokens) {
                var e_1, _a;
                var formattedQuery = '';
                try {
                    for (var _b = __values(tokens.items()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var node = _c.value;
                        var token = node.item;
                        // order of statements is important
                        if (token.type === tokenTypes.DBT_START_VAR) {
                            formattedQuery = _this.formatVariableStart(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.DBT_END_VAR) {
                            formattedQuery = _this.formatVariableEnd(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.DBT_START_TEMPLATE) {
                            formattedQuery = _this.formatTemplateStart(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.DBT_END_TEMPLATE) {
                            formattedQuery = _this.formatTemplateEnd(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.DBT_START_MARKERS) {
                            formattedQuery = _this.formatDBTStartMarker(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.DBT_END_MARKERS) {
                            formattedQuery = _this.formatDBTEndMarker(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.WHITESPACE) ;
                        else if (token.type === tokenTypes.LINE_COMMENT) {
                            formattedQuery = _this.formatLineComment(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.BLOCK_COMMENT) {
                            formattedQuery = _this.formatBlockComment(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.RESERVED_TOPLEVEL) {
                            formattedQuery = _this.formatToplevelReservedWord(node, formattedQuery);
                            _this.previousReservedWord = token;
                        }
                        else if (token.type === tokenTypes.RESERVED_NEWLINE) {
                            formattedQuery = _this.formatNewlineReservedWord(node, formattedQuery);
                            _this.previousReservedWord = token;
                        }
                        else if (token.type === tokenTypes.RESERVED) {
                            formattedQuery = _this.formatReservedWord(node, formattedQuery);
                            _this.previousReservedWord = token;
                        }
                        else if (token.type === tokenTypes.OPEN_PAREN) {
                            formattedQuery = _this.formatOpeningParentheses(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.CLOSE_PAREN) {
                            formattedQuery = _this.formatClosingParentheses(node, formattedQuery);
                        }
                        else if (token.value === ',') {
                            formattedQuery = _this.formatComma(node, formattedQuery);
                        }
                        else if (token.value === ':') {
                            formattedQuery = _this.formatWithSpaceAfter(node, formattedQuery);
                        }
                        else if (token.value === '.') {
                            formattedQuery = _this.formatWithoutSpaces(node, formattedQuery);
                        }
                        else if (token.value === ';') {
                            formattedQuery = _this.formatQuerySeparator(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.OPERATOR) {
                            formattedQuery = _this.formatOperator(node, formattedQuery);
                        }
                        else if (token.type === tokenTypes.WORD) {
                            formattedQuery = _this.formatWord(node, formattedQuery);
                        }
                        else {
                            formattedQuery = _this.formatWithSpaces(node, formattedQuery);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                var appendix = _this.newline ? '\n' : '';
                return formattedQuery.trim() + appendix;
            };
            this.indentComment = function (comment) {
                return comment.replace(/\n/g, '\n' + _this.indentation.getIndent());
            };
            this.trimTrailingWhitespace = function (node, query) {
                var appendix = '';
                var nextType = node.next ? node.next.item.type : undefined;
                if (nextType === tokenTypes.LINE_COMMENT) {
                    appendix = '\n';
                }
                return trimEnd(query) + appendix;
            };
            this.addNewline = function (query, lines) {
                if (lines === void 0) { lines = 1; }
                return trimEnd(query) + '\n'.repeat(lines) + _this.indentation.getIndent();
            };
            this.getNextNodeNonWhitespace = function (node) {
                var nextNode = node.next;
                while (nextNode && nextNode.item.type === tokenTypes.WHITESPACE) {
                    nextNode = nextNode.next;
                }
                return nextNode;
            };
            this.getPreviousNodeNonWhitespace = function (node) {
                var previousNode = node.previous;
                while (previousNode && previousNode.item.type === tokenTypes.WHITESPACE) {
                    previousNode = previousNode.previous;
                }
                return previousNode;
            };
            this.countWordsBetweenParenthesis = function (node) {
                if (node.item.type !== tokenTypes.OPEN_PAREN) {
                    return 0;
                }
                var wordCount = 0;
                var nextNode = node.next;
                while (nextNode && nextNode.item.type !== tokenTypes.CLOSE_PAREN) {
                    if (nextNode.item.value !== ',') {
                        wordCount++;
                    }
                    nextNode = nextNode.next;
                }
                return wordCount;
            };
            /*
             * FORMATTERS
             */
            this.formatVariableStart = function (node, query) {
                _this.inVariableBlock = true;
                var token = node.item;
                var nextToken = _this.getNextNodeNonWhitespace(node);
                _this.variableName = nextToken ? nextToken.item.value : '';
                return query + addWhitespace(removeWhitespace(token.value));
            };
            this.formatVariableEnd = function (node, query) {
                _this.inVariableBlock = false;
                // Remove whitespaces from token and add space at the end
                var token = node.item.value;
                var nextToken = _this.getNextNodeNonWhitespace(node);
                query += addWhitespace(removeWhitespace(token));
                // If the next token is a reserved word (as, when,...) don't add
                // a new line.
                var noNewLine = nextToken &&
                    (nextToken.item.type === tokenTypes.RESERVED || nextToken.item.type === tokenTypes.OPERATOR ||
                        DbtConfig.dbtControl.includes(nextToken.item.value.toLowerCase()));
                if (noNewLine) {
                    return query;
                }
                /*
                 ** Logic when to add a double new line **
                 * If the next token is a reserved top level sql word -> add 2 lines
                 * If the next token is a dbt template start token -> add 2 lines
                 */
                var doubleLine = nextToken &&
                    (nextToken.item.type === tokenTypes.RESERVED_TOPLEVEL || nextToken.item.type === tokenTypes.DBT_START_TEMPLATE);
                var lines = doubleLine ? 2 : 1;
                return _this.addNewline(query, lines);
            };
            this.formatTemplateStart = function (node, query) {
                _this.inTemplateBlock = true;
                var token = node.item;
                var nextToken = _this.getNextNodeNonWhitespace(node);
                var previousToken = _this.getPreviousNodeNonWhitespace(node);
                var secondNextToken = nextToken ? _this.getNextNodeNonWhitespace(nextToken) : undefined;
                var newToken = addWhitespace(removeWhitespace(token.value));
                /*
                 ** Currently there are two special cases in jinja that we account for here:
                 * 1. {% else % }: needs to be format 1 indent down
                 * 2. {% if is_incremental() %}: needs to reset to indent: 0
                 */
                if (nextToken && nextToken.item.value.toLowerCase() === 'else') {
                    _this.indentation.decreaseTopLevel();
                    query = _this.addNewline(query);
                    _this.indentation.increaseToplevel();
                }
                else if (nextToken &&
                    DbtConfig.dbtControl.includes(nextToken.item.value.toLowerCase()) &&
                    (secondNextToken && secondNextToken.item.value.toLowerCase() === 'is_incremental')) {
                    _this.indentation.reset();
                    _this.inIncrementalBlock = true;
                    query = _this.addNewline(query, 2);
                }
                else if (nextToken && nextToken.item.type === tokenTypes.DBT_END_MARKERS) {
                    var isTopLevel = DbtConfig.topLevelWords.includes(nextToken.item.value.toLowerCase());
                    if (isTopLevel) {
                        _this.indentation.reset();
                    }
                    else {
                        _this.indentation.decreaseTopLevel();
                    }
                    query = _this.addNewline(query);
                }
                else if (nextToken &&
                    nextToken.item.type === tokenTypes.DBT_START_MARKERS &&
                    !DbtConfig.singleLineWords.includes(nextToken.item.value.toLowerCase())) {
                    _this.indentation.increaseToplevel();
                    if (previousToken && previousToken.item.type === tokenTypes.WORD) {
                        // if previous token is a word, give it some space and decrease indentation
                        _this.indentation.decreaseTopLevel();
                        query = _this.addNewline(query, 2);
                    }
                }
                return query + newToken;
            };
            this.formatTemplateEnd = function (node, query) {
                _this.inTemplateBlock = false;
                var token = node.item;
                query += addWhitespace(token.value);
                var previousToken = _this.getPreviousNodeNonWhitespace(node);
                var doubleLineMarker = previousToken && previousToken.item.value
                    ? DbtConfig.doubleLineMarkers.includes(previousToken.item.value.toLowerCase())
                    : false;
                var lines = doubleLineMarker ? 2 : 1;
                return _this.addNewline(query, lines);
            };
            this.formatDBTStartMarker = function (node, query) {
                var token = node.item;
                return query + addWhitespace(token.value);
            };
            this.formatDBTEndMarker = function (node, query) {
                var token = node.item;
                return query + addWhitespace(token.value);
            };
            this.formatLineComment = function (node, query) {
                var token = node.item;
                return _this.addNewline(query + token.value);
            };
            this.formatBlockComment = function (node, query) {
                var token = node.item;
                return _this.addNewline(_this.addNewline(query) + _this.indentComment(token.value));
            };
            this.formatReservedWord = function (node, query) {
                var token = node.item;
                token.value =
                    _this.upper && !_this.inTemplateBlock && !_this.inVariableBlock ? token.value.toUpperCase() : token.value;
                return _this.formatWithSpaces(node, query);
            };
            this.formatToplevelReservedWord = function (node, query) {
                var token = node.item;
                var prevToken = _this.getPreviousNodeNonWhitespace(node);
                // if we are inside dbt template brackets don't add newline
                // there is some sql and jinja overlap that we account for here.
                if ((prevToken && prevToken.item.type === tokenTypes.DBT_START_TEMPLATE) ||
                    _this.inTemplateBlock ||
                    _this.inVariableBlock) {
                    var newToken_1 = addWhitespace(token.value.toLowerCase());
                    return query + equalizeWhitespace(newToken_1);
                }
                // WITH table as () is a special case.
                if (token.value.toLowerCase() === 'with') {
                    var newToken_2 = addWhitespace(_this.upper ? token.value.toUpperCase() : token.value);
                    return query + equalizeWhitespace(newToken_2);
                }
                // when in `is_incremental` block keep current indentation level
                // if the previous token is a dbt config variable keep current indentation
                var previousConfigBlock = _this.variableName.toLowerCase() === 'config';
                if (_this.inIncrementalBlock || previousConfigBlock) {
                    _this.variableName = '';
                    _this.inIncrementalBlock = false;
                }
                else {
                    _this.indentation.decreaseTopLevel();
                }
                query = _this.addNewline(query, previousConfigBlock ? 2 : 1);
                // TODO: Make reusable function
                var newToken = _this.upper ? token.value.toUpperCase() : token.value;
                query += equalizeWhitespace(newToken);
                _this.indentation.increaseToplevel();
                query = _this.addNewline(query);
                return query;
            };
            this.formatNewlineReservedWord = function (node, query) {
                var token = node.item;
                if (_this.inTemplateBlock) {
                    var newToken_3 = addWhitespace(token.value.toLowerCase());
                    return query + equalizeWhitespace(newToken_3);
                }
                var newToken = _this.upper ? token.value.toUpperCase() : token.value;
                return _this.addNewline(query) + addWhitespace(newToken);
            };
            // Opening parentheses increase the block indent level and start a new line
            this.formatOpeningParentheses = function (node, query) {
                // Take out the preceding space unless there was whitespace there in the original query
                // or another opening parens or line comment
                var preserveWhitespaceFor = [tokenTypes.WHITESPACE, tokenTypes.OPEN_PAREN, tokenTypes.LINE_COMMENT];
                if (node.previous && !preserveWhitespaceFor.includes(node.previous.item.type)) {
                    query = trimEnd(query);
                }
                // dirty fix for when we allow a word to have the same function as an opening parenthesis
                query += _this.upper ? node.item.value.toUpperCase() : node.item.value;
                _this.inlineBlock.beginIfPossible(node);
                var nextNode = _this.getNextNodeNonWhitespace(node);
                /*
                 ** Determine if text within parentheses should be a one liner
                 * 1. When the there is no text `()`
                 * 2. When there is only 1 word in between brackets
                 */
                _this.inlineOneLiner = _this.countWordsBetweenParenthesis(node) <= 1;
                // only increase block level when inline block is active and next token is not a closing parenthesis
                if (!_this.inlineBlock.isActive() && !_this.inlineOneLiner) {
                    _this.indentation.increaseBlockLevel();
                    query = _this.addNewline(query);
                }
                return query;
            };
            // Closing parentheses decrease the block indent level
            this.formatClosingParentheses = function (node, query) {
                // dirty fix for when we allow a word to have the same function as a closing parenthesis
                node.item.value = _this.upper ? node.item.value.toUpperCase() : node.item.value;
                if (_this.inlineBlock.isActive()) {
                    _this.inlineBlock.end();
                    return _this.formatWithSpaceAfter(node, query);
                }
                else if (_this.inlineOneLiner) {
                    _this.inlineOneLiner = false;
                    return _this.formatWithSpaceAfter(node, query);
                }
                else {
                    _this.indentation.decreaseBlockLevel();
                    return _this.formatWithSpaces(node, _this.addNewline(query));
                }
            };
            // Commas start a new line (unless within inline parentheses or SQL "LIMIT" clause)
            this.formatComma = function (node, query) {
                var token = node.item;
                query = _this.trimTrailingWhitespace(node, query) + token.value + ' ';
                if (_this.inlineBlock.isActive()) {
                    return query;
                }
                else if (/^LIMIT$/i.test(_this.previousReservedWord.value)) {
                    return query;
                }
                else {
                    return _this.addNewline(query);
                }
            };
            this.formatOperator = function (node, query) {
                var token = node.item;
                var prevToken = _this.getPreviousNodeNonWhitespace(node);
                if (prevToken && prevToken.item.type === tokenTypes.OPERATOR) {
                    return trimEnd(query) + removeWhitespace(token.value) + ' ';
                }
                return _this.formatWithSpaces(node, query);
            };
            this.formatWithSpaceAfter = function (node, query) {
                var token = node.item;
                return _this.trimTrailingWhitespace(node, query) + addWhitespace(token.value);
            };
            this.formatWithoutSpaces = function (node, query) {
                var token = node.item;
                return _this.trimTrailingWhitespace(node, query) + token.value;
            };
            this.formatWithSpaces = function (node, query) {
                var token = node.item;
                return query + addWhitespace(token.value);
            };
            this.formatWord = function (node, query) {
                var token = node.item;
                var newToken = token.value;
                if (_this.lowerWords) {
                    var isCamelCase$$1 = isCamelCase(token.value);
                    newToken = isCamelCase$$1 && _this.allowCamelcase ? token.value : token.value.toLowerCase();
                }
                return query + addWhitespace(newToken);
            };
            this.formatQuerySeparator = function (node, query) {
                var token = node.item;
                return _this.trimTrailingWhitespace(node, query) + token.value + '\n';
            };
            var indent = opt.indent, upper = opt.upper, newline = opt.newline, lowerWords = opt.lowerWords, allowCamelcase = opt.allowCamelcase;
            this.upper = upper || this.upper;
            this.newline = newline || this.newline;
            this.indentation = new Indentation(indent);
            this.lowerWords = lowerWords || this.lowerWords;
            this.allowCamelcase = allowCamelcase || this.allowCamelcase;
        }
        return Formatter;
    }());

    var getConfiguration = function (opt) {
        var identifier = opt.sql;
        return {
            reservedWords: presets['reservedWords'][identifier],
            reservedTopLevelWords: presets['reservedTopLevelWords'][identifier],
            reservedNewLineWords: presets['reservedNewLineWords'][identifier],
            stringTypes: presets['stringTypes'][identifier],
            openParens: presets['openParens'][identifier],
            closeParens: presets['closeParens'][identifier],
            indexedPlaceholderTypes: presets['indexedPlaceholderTypes'][identifier],
            namedPlaceholderTypes: presets['namedPlaceholderTypes'][identifier],
            lineCommentTypes: presets['lineCommentTypes'][identifier],
            specialWordChars: presets['specialWordChars'][identifier],
        };
    };
    /**
     * Formats the sql string.
     *
     * @param {String} query
     * @param {Options} opt
     * @return {String}
     */
    var format = function (query, opt) {
        if (opt === void 0) { opt = { sql: 'default', indent: 2 }; }
        if (!formatters.includes(opt.sql)) {
            throw Error("Unsupported SQL dialect: " + opt.sql);
        }
        var config = getConfiguration(opt);
        var tokens = new Tokenizer(config).tokenize(query);
        return new Formatter(opt).format(tokens);
    };

    return format;

})));
//# sourceMappingURL=dbt-formatter.umd.js.map
